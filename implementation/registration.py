"""
Registration Phase: Users obtain anonymous credentials.

This module implements the registration phase where users:
1. Prove Merkle tree membership (without revealing position)
2. Receive blind signature on their credential
3. Unblind to get anonymous credential
"""

from Crypto.Util.number import getRandomRange
from Crypto.Random import get_random_bytes
import hashlib
from typing import List, Tuple, Dict, Optional
from .merkle_tree import MerkleTree, create_user_identifier


class UserRegistration:
    """Handles user registration and credential issuance."""
    
    def __init__(self, user_id: str, secret: bytes, merkle_path: List[Tuple[bytes, bool]], 
                 merkle_root: bytes, rsa_n: int, rsa_e: int):
        """
        Initialize user registration.
        
        IMPORTANT: User generates their own secret. Authority never learns it.
        
        Args:
            user_id: User's public identifier
            secret: User's secret value (generated by user, unknown to authority)
            merkle_path: Merkle path for public identifier (authority provides)
            merkle_root: Root of the Merkle tree
            rsa_n: RSA modulus (public key)
            rsa_e: RSA public exponent
        """
        self.user_id = user_id
        self.secret = secret  # User's secret, authority never knows this
        self.merkle_path = merkle_path
        self.merkle_root = merkle_root
        self.rsa_n = rsa_n
        self.rsa_e = rsa_e
        
        # Public leaf (authority knows this)
        self.public_leaf = create_user_identifier(user_id, secret=None)
        
        # User commitment (authority doesn't know secret)
        self.user_commitment = create_user_identifier(user_id, secret)
        
        # Verify Merkle path for public identifier
        if not self._verify_merkle_path():
            raise ValueError("Invalid Merkle path")
    
    def _hash(self, data: bytes) -> bytes:
        """Hash function matching Merkle tree."""
        return hashlib.sha256(data).digest()
    
    def _verify_merkle_path(self) -> bool:
        """Verify that Merkle path is valid for public identifier."""
        # Verify path for public leaf (authority knows this)
        current_hash = self._hash(self.public_leaf)
        
        for sibling_hash, is_right in self.merkle_path:
            if is_right:
                combined = current_hash + sibling_hash
            else:
                combined = sibling_hash + current_hash
            current_hash = self._hash(combined)
        
        return current_hash == self.merkle_root
    
    def create_blinded_token(self) -> Tuple[int, int]:
        """
        Create blinded token for blind signature.
        
        Token is based on user commitment (user_id + secret).
        Authority never sees the unblinded token or secret.
        
        Returns:
            Tuple of (blinded_token, blinding_factor)
        """
        # Create token from user commitment: H(user_id || secret)
        # Authority never learns secret, so cannot link token to user
        token_data = self.user_id.encode() + self.secret
        token_hash = int.from_bytes(self._hash(token_data), 'big')
        token = token_hash % self.rsa_n
        
        # Generate random blinding factor
        r = getRandomRange(2, self.rsa_n - 1)
        
        # Blind token: m' = m · r^e mod n
        blinded_token = (token * pow(r, self.rsa_e, self.rsa_n)) % self.rsa_n
        
        return blinded_token, r
    
    def unblind_signature(self, blinded_signature: int, blinding_factor: int) -> int:
        """
        Unblind the signature received from authority.
        
        Args:
            blinded_signature: Signature on blinded token
            blinding_factor: The blinding factor used
            
        Returns:
            Unblinded signature on original token
        """
        # Unblind: σ = σ' · r^(-1) mod n
        r_inv = pow(blinding_factor, -1, self.rsa_n)
        signature = (blinded_signature * r_inv) % self.rsa_n
        
        return signature
    
    def verify_credential(self, signature: int) -> bool:
        """
        Verify that the credential (signature) is valid.
        
        Args:
            signature: The unblinded signature
            
        Returns:
            True if signature is valid, False otherwise
        """
        # Recreate token from user commitment
        token_data = self.user_id.encode() + self.secret
        token_hash = int.from_bytes(self._hash(token_data), 'big')
        token = token_hash % self.rsa_n
        
        # Verify signature: token == signature^e mod n
        verified_token = pow(signature, self.rsa_e, self.rsa_n)
        
        return verified_token == token
    
    def get_credential(self) -> Dict:
        """
        Get user's credential (to be stored securely).
        
        Returns:
            Dictionary containing credential components
        """
        # Create blinded token
        blinded_token, r = self.create_blinded_token()
        
        # In real protocol, this would be sent to authority
        # For now, we'll simulate the authority signing
        # (In actual implementation, authority.sign_blinded_token would be called)
        
        return {
            'user_id': self.user_id,
            'merkle_path': [(h.hex(), is_right) for h, is_right in self.merkle_path],
            'merkle_root': self.merkle_root.hex(),
            'blinding_factor': r,
            'blinded_token': blinded_token
        }


class RegistrationProtocol:
    """Complete registration protocol between user and authority."""
    
    @staticmethod
    def register_user(
        user_id: str,
        secret: bytes,
        merkle_path: List[Tuple[bytes, bool]],
        merkle_root: bytes,
        rsa_n: int,
        rsa_e: int,
        authority_signer
    ) -> Dict:
        """
        Complete registration protocol.
        
        Args:
            user_id: User identifier
            secret: User secret
            merkle_path: Merkle path from authority
            merkle_root: Merkle root
            rsa_n: RSA modulus
            rsa_e: RSA exponent
            authority_signer: Function that signs blinded tokens
            
        Returns:
            User's credential
        """
        # User creates registration request
        user_reg = UserRegistration(user_id, secret, merkle_path, merkle_root, rsa_n, rsa_e)
        
        # User blinds token
        blinded_token, r = user_reg.create_blinded_token()
        
        # Authority signs blinded token (without seeing actual token)
        blinded_signature = authority_signer(blinded_token)
        
        # User unblinds signature
        signature = user_reg.unblind_signature(blinded_signature, r)
        
        # User verifies credential
        if not user_reg.verify_credential(signature):
            raise ValueError("Invalid credential received")
        
        # Return credential
        # IMPORTANT: Do not include secret or anything that reveals it
        # User must store secret separately and securely
        return {
            'signature': signature,
            'merkle_path': merkle_path,
            'merkle_root': merkle_root.hex(),
            'user_id': user_id,  # Public identifier is okay
            # Note: secret is NOT included - user stores it separately
        }


def example_registration():
    """Example usage of registration phase."""
    # Simulate authority setup
    from .setup import AuthoritySetup
    
    authority = AuthoritySetup()
    authority.generate_rsa_keys()
    
    # Authority only knows public user IDs, NOT secrets
    user_ids = ['student1', 'student2']
    authority.add_authorized_users(user_ids)
    authority.build_merkle_tree()
    
    # User generates their own secret (authority never learns this)
    user_id = 'student1'
    secret = get_random_bytes(32)  # User generates secret randomly
    
    # Authority provides Merkle path for public identifier
    merkle_path = authority.get_user_merkle_path(0)
    merkle_root = authority.merkle_tree.root
    rsa_n = authority.rsa_key.n
    rsa_e = authority.rsa_key.e
    
    # Register user
    credential = RegistrationProtocol.register_user(
        user_id, secret, merkle_path, merkle_root, rsa_n, rsa_e,
        authority.sign_blinded_token
    )
    
    print("Registration successful!")
    print(f"Credential signature: {credential['signature']}")
    print("Note: User secret is NOT known to authority")
    
    return credential, secret  # Return secret so user can store it


if __name__ == '__main__':
    example_registration()

